growth<-function(x){
  y=NULL
  for (i in seq_along(x)) {
    y[i]=(x[i]-x[i-1])/x[i-1]
  }
  return(y)
}

changeToNum<-function(x){ # x est un data frame
  options(digits=20)
  y=NULL
  for (i in 1:dim(x)[2]) {
    y[[i]]=as.numeric(x[,i])
  }
  z=data.frame(y);colnames(z)=colnames(x)
  z
}

####

changeToNum2<-function(x){ # x est un data frame
  options(digits=20)
  y=NULL
  for (i in 1:dim(x)[2]) {
    y[[i]]=as.numeric(unlist(x[,i]))
  }
  z=data.frame(y);colnames(z)=colnames(x)
  z
}


######
removeColNA<-function(x){ # fonction pour enlever colonnes ayant que des NA dans les donnees monetaires
  y=NULL
  for (i in 1:dim(x)[2]) {
    y[i]=ifelse(colnames(x[,i])=="NA-NA",i,NA)
  }
  x[,-(na.exclude(y))]
}
#####
trsfunc<-function(x){# x un data frame des transferts
  trs<-x%>%t()%>%data.frame()
  colnames(trs)<-trs[1,]      # pour donner au colonnes les noms des pays
  trs=trs[-1,]                # pour enlever la ligne des noms de pays
  y=NULL;d=NULL
  for (i in 1:dim(trs)[1]) {  # fonction pour identifier les lignes des pourcentages
    y[i]=ifelse("EN %" %in% trs[i,1],i,NA)
    d[i]=ifelse("EN %" %in% trs[i,1],NA,as.Date(as.numeric(trs[i,1]),origin="1900-01-01"))

  }
  trs=trs[-na.exclude(y),]   # enlever les lignes des pourcentages
  trs=trs[,-1]               # enlever la premiere colonne des dates
  rownames(trs)<-(na.exclude(as.Date(d)))
  trs
}




###
varSelect<-function(x){ # to select SDG variables with at least 20 data available
  y=NULL;z=NULL;d=NULL
  for (i in 1:dim(x)[2]) {
    y[i]=ifelse((count(na.exclude(x[,i]))<20),NA,colnames(x[,i])) # Exclure les variables ayant moins de 20 observations
  }

  col1=na.exclude(y)
  d=x[,col1]
  for (j in 1:dim(d)[2]) {
    z[j]=ifelse((length(unlist(unique(na.exclude(d[,j]))))<10)==TRUE,NA,colnames(d[,j])) # Exclure les variables dont les donnees uniques (non dupliquees) sont inferieures a 10

  }
  col2=na.exclude(z)
  d[,col2]

}

############################################3333
#aTSA::adf.test(df_sdg$sdg3_tb)
# une fonction qui indique si une variable est stationnaire en niveau
#####
tadf<-function(x){
  pmax=trunc((length(x))^(1/4))
  y=aTSA::adf.test(x,nlag = pmax,output = F)
  d=do.call(rbind,list(y$type1[pmax,],y$type2[pmax,],y$type3[pmax,])) # select the last row which correspond to the highest lag
  Stat_pv=d[,"p.value"]  # les probabilites
  Stationnaire=ifelse(Stat_pv<0.05,"Oui","Non")
  return(ifelse(("Oui" %in% Stationnaire)==TRUE,"Oui","Non"))

}

### stationnarity for each column of a data frame
tadf_df<-function(x){ # x est un data frame de donnees numeriques
  y=NULL
  colu=colnames(x)
  for (i in 1:length(colu)) {
    y[i]=tadf(c(x[,colu[i]]))
    #y[i]=tadf(log(c(x[,colu[i]])))
   # y[i]=tadf(diff(c(x[,colu[i]]),differences=2))
  }
  #data.frame(colnames(x),y)
  return(y)
}
#


zo<-data.frame(df_sdg[1:20,]);colnames(zo)
tadf_df(zo)


zo%>%
  tadf_df()
df_pib[31:61,-1]%>%tadf_df()
df_sdg[,-1]%>%
  tadf_df()  # Certaines variables sont stationnaires et d'autres non
# Nous ne faisons pas de test de GRANGER, mais v√©rifions seulement l'association des variables

test_adf<-function(x){
  pmax=trunc((length(x))^(1/4))
  y=aTSA::adf.test(x,nlag = pmax,output = F)
  return(y)
}



# une fonction qui donne correlation et pvalue
cor_pvalue<-function(x,y){
  y=cor.test(x,y,method="pearson",conf.level=0.95)
  list(cor=y$estimate,pval=y$p.value)
}

#################33333
fcor<-function(x,dat){ #x est la variable contenant les 2 colonnes de combinaisons de variables
                      # dat est le data frame contenant les donnees
   y=NULL;Cor=NULL;Cor_pv=NULL;Cor_sig=NULL
  for (i in 1:dim(x)[1]) {
    y[[i]]=cor_pvalue(unlist(dat[,x[i,1]]),unlist(dat[,x[i,2]]))
    Cor[i]=round((y[[i]])$cor,digits = 2)   # correlation
    Cor_pv[i]=round(y[[i]]$pval,digits = 3 )  # pvalue
    Cor_sig[i]=ifelse(Cor_pv[i]>=0.1,"Non",
                      ifelse(Cor_pv[i]>=0.05,"Oui10%","Oui5%"))

  }
  data.frame(Cor,Cor_pv,Cor_sig)
}


###
fgranger<-function(x,dat){ # x:df des combinaisons de noms de variables; dat: data frame des donnees
  y=NULL;Grg_pv=NULL;Caus=NULL
  for (i in 1:dim(x)) {
    y[[i]]=lmtest::grangertest(dat[,x[i,1]],dat[,x[i,2]],order=1)
    Grg_pv[i]=round((y[[i]])["Pr(>F)"],digits = 2); Grg_pv[[i]]=unlist(Grg_pv[[i]])[2]
    #Caus[i]=ifelse(Grg_pv[[i]]<0.0544,"Oui","Non")
    Caus[i]=ifelse(Grg_pv[i]>=0.1,"Non",
                   ifelse(Grg_pv[i]>=0.05,"Oui10%","Oui5%"))
  }
  data.frame(Grg_pv=t(data.frame(t(Grg_pv))),Caus)
  #(na.exclude(Grg_pv))

}

####
gtheme<-function(...){
  theme_classic()+
    theme(axis.ticks = element_blank(),
          axis.line=element_blank(),
          axis.text = element_text(colour="black"),
          plot.margin = margin(1,1,1,3)
    )+
    theme(legend.position = "top", legend.direction = "horizontal")

}

